## 41. First Missing Positive

![image-20210329204706941](力扣41-50.assets/image-20210329204706941.png)

### solution 1:

把小于等于`len`的数放在`i-1`处，最后从头开始，找到第一个不是`i-1`的数，该数即为所求。

```c++
int firstMissingPositive(vector<int>& nums) {
	int n = nums.size();
	for (int i = 0; i < n; i++)
		while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])
			swap(nums[i], nums[nums[i] - 1]);
	for (int i = 0; i < n; i++)
		if (nums[i] != i + 1)
			return i + 1;
	return n + 1;
}
```

## 42. Trapping Rain Water

![image-20210329205728118](力扣41-50.assets/image-20210329205728118.png)

### solution 1: find max

先找到最大值，然后算出最大可用面积`max * height.size()`，然后再从左和从右依次向`max`寻求，对每一个点计算多算的面积。

```c++
int trap(vector<int>& height) {
	if (height.size() == 0) return 0;
	int pos = 0, max = 0;
	for (size_t i = 0; i < height.size(); i++) {
		if (height[i] > max) {
			max = height[i];
			pos = i;
		}
	}
	int water = max * height.size();
	for (int left = 0, current_max = 0, max_pos = 0; left <= pos; left++) {
		if (height[left] > current_max) {
			current_max = height[left];
			max_pos = left;
		}
		water -= (height[left] + (max - current_max));
	}
	for (int right = height.size() - 1, current_max = 0, max_pos = 0; right > pos; right--) {
		if (height[right] > current_max) {
			current_max = height[right];
			max_pos = right;
		}
		water -= (height[right] + (max - current_max));
	}
	return water;
}
```

