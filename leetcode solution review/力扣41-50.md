## 41. First Missing Positive

![image-20210329204706941](力扣41-50.assets/image-20210329204706941.png)

### solution 1:

把小于等于`len`的数放在`i-1`处，最后从头开始，找到第一个不是`i-1`的数，该数即为所求。

```c++
int firstMissingPositive(vector<int>& nums) {
	int n = nums.size();
	for (int i = 0; i < n; i++)
		while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])
			swap(nums[i], nums[nums[i] - 1]);
	for (int i = 0; i < n; i++)
		if (nums[i] != i + 1)
			return i + 1;
	return n + 1;
}
```

## 42. Trapping Rain Water

![image-20210329205728118](力扣41-50.assets/image-20210329205728118.png)

### solution 1: find max

先找到最大值，然后算出最大可用面积`max * height.size()`，然后再从左和从右依次向`max`寻求，对每一个点计算多算的面积。

```c++
int trap(vector<int>& height) {
	if (height.size() == 0) return 0;
	int pos = 0, max = 0;
	for (size_t i = 0; i < height.size(); i++) {
		if (height[i] > max) {
			max = height[i];
			pos = i;
		}
	}
	int water = max * height.size();
	for (int left = 0, current_max = 0, max_pos = 0; left <= pos; left++) {
		if (height[left] > current_max) {
			current_max = height[left];
			max_pos = left;
		}
		water -= (height[left] + (max - current_max));
	}
	for (int right = height.size() - 1, current_max = 0, max_pos = 0; right > pos; right--) {
		if (height[right] > current_max) {
			current_max = height[right];
			max_pos = right;
		}
		water -= (height[right] + (max - current_max));
	}
	return water;
}
```

### solution 2: iteration from left and right

从左和右向中间迭代，每次移动较矮的那一边的柱子，这样能够保证一定是在包含在`left`和`right`之内的可用水柱。

```c++
int trap(int A[], int n) {
	int left = 0; int right = n - 1;
	int res = 0;
	int maxleft = 0, maxright = 0;
	while (left <= right) {
		if (A[left] <= A[right]) {
			if (A[left] >= maxleft) maxleft = A[left];
			else res += maxleft - A[left];
			left++;
		}
		else {
			if (A[right] >= maxright) maxright = A[right];
			else res += maxright - A[right];
			right--;
		}
	}
	return res;
}
```

## 43. Multiply Strings

![image-20210406183222743](力扣41-50.assets/image-20210406183222743.png)

### solution 1:

正常思路逐位相乘即可。

```c++
string multiply(string num1, string num2) {
    unsigned int l1 = num1.size(), l2 = num2.size();
    if (l1 == 0 || l2 == 0 || num1 == "0" || num2 == "0") return "0";

    vector<int> v(l1 + l2, 0);

    for (unsigned int i = 0; i < l1; i++) {
        int carry = 0;
        int n1 = (int)(num1[l1 - i - 1] - '0');//Calculate from rightmost to left
        for (unsigned int j = 0; j < l2; j++) {
            int n2 = (num2[l2 - j - 1] - '0');//Calculate from rightmost to left

            int sum = n1 * n2 + v[i + j] + carry;
            carry = sum / 10;
            v[i + j] = sum % 10;
        }
        if (carry > 0)
            v[i + l2] += carry;

    }
    int start = l1 + l2 - 1;
    while (v[start] == 0) start--;
    if (start == -1) return "0";

    string s = "";
    for (int i = start; i >= 0; i--)
        s += (char)(v[i] + '0');
    return s;
}
```

